/*
 *  popsin.c
 *  This file is part of LIME, the versatile line modeling engine
 *
 *  Copyright (C) 2006-2014 Christian Brinch
 *  Copyright (C) 2015-2016 The LIME development team
 *
***TODO:
	- Change the definition of the file format so that nmol is now written with the other mol[] scalars.
 */

#include "lime.h"


void
popsin(configInfo *par, struct grid **gp, molData **md, int *popsdone){
  FILE *fp;
  int i,j,k,dummyNPart,dummyNTrans;
  double dummy;
  struct cell *dc=NULL; /* Not used at present. */
  unsigned long numCells,nExtraSinks;

  if((fp=fopen(par->restart, "rb"))==NULL){
    if(!silent) bail_out("Error reading binary output populations file!");
    exit(1);
  }

  par->numDensities = 1;
  fread(&par->radius,   sizeof(double), 1, fp);
  fread(&par->ncell,    sizeof(int), 1, fp);
  fread(&par->nSpecies, sizeof(int), 1, fp);
  if( par->nSpecies < 0 || par->nSpecies > MAX_NSPECIES )
    {
      if(!silent) bail_out("Error reading binary output populations file : is this really a binary output file generated by lime ?");
      exit(1);
    }

  *md=realloc(*md, sizeof(molData)*par->nSpecies);

  for(i=0;i<par->nSpecies;i++){
    (*md)[i].part = NULL;
    (*md)[i].eterm = NULL;
    (*md)[i].gstat = NULL;
    (*md)[i].cmb = NULL;
    fread(&(*md)[i].nlev,  sizeof(int),        1,fp);
    fread(&(*md)[i].nline, sizeof(int),        1,fp);
    fread(&dummyNPart,     sizeof(int),        1,fp);
    for(j=0;j<dummyNPart;j++) fread(&dummyNTrans, sizeof(int), 1,fp);
    (*md)[i].lal=malloc(sizeof(int)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].lal[j],    sizeof(int), 1,fp);
    (*md)[i].lau=malloc(sizeof(int)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].lau[j],    sizeof(int), 1,fp);
    (*md)[i].aeinst=malloc(sizeof(double)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].aeinst[j], sizeof(double), 1,fp);
    (*md)[i].freq=malloc(sizeof(double)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].freq[j],   sizeof(double), 1,fp);
    (*md)[i].beinstl=malloc(sizeof(double)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].beinstl[j],sizeof(double), 1,fp);
    (*md)[i].beinstu=malloc(sizeof(double)*(*md)[i].nline);
    for(j=0;j<(*md)[i].nline;j++) fread(&(*md)[i].beinstu[j],sizeof(double), 1,fp);
    for(j=0;j<(*md)[i].nline;j++) fread(&dummy,sizeof(double), 1,fp);
    fread(&dummy, sizeof(double),      1,fp);
    fread(&dummy, sizeof(double),   1,fp);
  }

  *gp=malloc(sizeof(struct grid)*par->ncell);

  for(i=0;i<par->ncell;i++){
    (*gp)[i].v1 = NULL;
    (*gp)[i].v2 = NULL;
    (*gp)[i].v3 = NULL;
    (*gp)[i].dens = NULL;
    (*gp)[i].abun = NULL;
    (*gp)[i].dir = NULL;
    (*gp)[i].neigh = NULL;
    (*gp)[i].w = NULL;
    (*gp)[i].ds = NULL;
    fread(&(*gp)[i].id, sizeof (*gp)[i].id, 1, fp);
    fread(&(*gp)[i].x, sizeof (*gp)[i].x, 1, fp);
    fread(&(*gp)[i].vel, sizeof (*gp)[i].vel, 1, fp);
    fread(&(*gp)[i].sink, sizeof (*gp)[i].sink, 1, fp);
    (*gp)[i].mol=malloc(par->nSpecies*sizeof(struct populations));
    for(j=0;j<par->nSpecies;j++)
      fread(&(*gp)[i].mol[j].nmol, sizeof(double), 1, fp);
    fread(&(*gp)[i].dopb_turb, sizeof (*gp)[i].dopb_turb, 1, fp);
    for(j=0;j<par->nSpecies;j++){
      (*gp)[i].mol[j].pops=malloc(sizeof(double)*(*md)[j].nlev);
      for(k=0;k<(*md)[j].nlev;k++) fread(&(*gp)[i].mol[j].pops[k], sizeof(double), 1, fp);
      (*gp)[i].mol[j].cont = NULL;
      for(k=0;k<(*md)[j].nline;k++) fread(&dummy, sizeof(double), 1, fp);
      for(k=0;k<(*md)[j].nline;k++) fread(&dummy, sizeof(double), 1, fp);
      fread(&(*gp)[i].mol[j].dopb,sizeof(double), 1, fp);
      fread(&(*gp)[i].mol[j].binv,sizeof(double), 1, fp);
      (*gp)[i].mol[j].partner=NULL;
    }
    fread(&dummy, sizeof(double), 1, fp);
    fread(&dummy, sizeof(double), 1, fp);
    fread(&dummy, sizeof(double), 1, fp);

    (*gp)[i].B[0] = 0.0;
    (*gp)[i].B[1] = 0.0;
    (*gp)[i].B[2] = 0.0;
  }
  fclose(fp);

  delaunay(DIM, *gp, (unsigned long)par->ncell, 0, 1, &dc, &numCells);

  /* We just asked delaunay() to flag any grid points with IDs lower than par->pIntensity (which means their distances from model centre are less than the model radius) but which are nevertheless found to be sink points by virtue of the geometry of the mesh of Delaunay cells. Now we need to reshuffle the list of grid points, then reset par->pIntensity, such that all the non-sink points still have IDs lower than par->pIntensity.
  */ 
  nExtraSinks = reorderGrid((unsigned long)par->ncell, *gp);
  par->pIntensity -= nExtraSinks;
  par->sinkPoints += nExtraSinks;

  distCalc(par, *gp);
  getVelocities(par,*gp);

  par->dataFlags |= (1 << DS_bit_x);
  par->dataFlags |= (1 << DS_bit_neighbours);
  par->dataFlags |= (1 << DS_bit_velocity);
  par->dataFlags |= (1 << DS_bit_density);
  par->dataFlags |= (1 << DS_bit_abundance);
  par->dataFlags |= (1 << DS_bit_turb_doppler);
  par->dataFlags |= (1 << DS_bit_temperatures);
/*  par->dataFlags |= (1 << DS_bit_magfield); commented out because we are not yet reading it in popsin (and may never do so) */
  par->dataFlags |= (1 << DS_bit_ACOEFF);
  par->dataFlags |= (1 << DS_bit_populations);

//**** should fill in any missing info via the appropriate function calls.

  *popsdone=1;

  free(dc);
}

